# ============================================================================
# TRINITY OS DISPLAY SYSTEM
# Displays scrolling status messages on a single console LED
# Receives message selection via db Setting (register 512)
# Message IDs 1-15 correspond to different Trinity system states
# ============================================================================
#ignorelimits
# Device aliases
alias ConDisplay d0     # Console LED panel for scrolling text display

# Register aliases
alias MessageID r15     # Current message ID from db Setting (1-15)
alias PrevMessageID r14 # Previous message ID (for change detection)
alias SDisplay r13      # String buffer for console display (holds 5 characters)
alias SBuffer r12       # Temporary buffer for character extraction
alias RBuffer r11       # Read buffer - holds current string being displayed (6 chars)
alias PartCount r10     # Number of string parts in current message (from stack)
alias SavedSP r9        # Saved stack pointer for looping back to message start
alias StackPointer r8   # Temporary stack pointer for loading messages

# ============================================================================
# INITIAL SETUP
# ============================================================================
s ConDisplay Mode 10    # Set console to string display mode
move PrevMessageID 0    # Initialize previous message to 0 (no message)
move RBuffer 0          # Initialize read buffer to empty
move PartCount 0        # Initialize part counter
move SavedSP 0          # Initialize saved stack pointer
define STACK_MAX 40    # Total stack depth

# ============================================================================
# MAIN LOOP
# ============================================================================
Main:
    # Read message ID from IC housing
    get MessageID db 511            # Get requested message (1-15)
    
    # Check if message has changed
    bne MessageID PrevMessageID LoadNewMessage
    
    # ========================================================================
    # STRING SCROLLER - Scrolls current message across display
    # ========================================================================
    
    # Get next string chunk if buffer is empty
    beqzal RBuffer StringGet           
    
beqzal r3 Main


    # Extract leftmost character from RBuffer
    srl SBuffer RBuffer 40              # Shift right 40 bits to get leftmost char
    brnez SBuffer 2                     # Skip if character exists
    move SBuffer STR(" ")               # If empty, use space character
    
    # Shift display left by 1 character and insert new char
    sll SDisplay SDisplay 8             # Shift left 8 bits (make room for new char)
    ins SDisplay 0 8 SBuffer            # Insert character at position 0
    
    # Shift RBuffer left by 1 character (consume the character)
    sll RBuffer RBuffer 8               # Shift left 8 bits
    
output:
    # Update display
    s ConDisplay Setting SDisplay       # Display current scrolling text
    yield                               # Let other scripts run
    j Main                              # Loop forever

# ============================================================================
# LOAD NEW MESSAGE SUBROUTINE
# Resets the stack pointer to the start of the selected message
# ============================================================================
LoadNewMessage:
 get StackPointer db MessageID
 get StackPointer db StackPointer 
 move sp StackPointer


# ============================================================================
# STRING GET SUBROUTINE
# Pops next value from stack - either part count or string chunk
# If part count is encountered, reset stack pointer to loop message
# ============================================================================
StringGet:

    pop RBuffer                         # Pop next value from stack
    
    # Check if this is a part count (numeric, not a string)
    # If PartCount is 0, this is the first pop - it's the part count
    beqz PartCount LoadPartCount
    
    # Check if popped value equals PartCount (we've looped back)
    brne RBuffer PartCount 2
    j LoopMessage                       # Reset to beginning of message
    
    j ra                                # Return with string in RBuffer

LoadPartCount:
    move PartCount RBuffer              # Store part count
    move SavedSP sp                     # Save stack position AFTER the part count
    move RBuffer 0                      # Clear RBuffer (not a string yet)
    j StringGet                                # Return to get first string

LoopMessage:
    move sp SavedSP                     # Reset stack pointer to after part count
    move RBuffer 0                      # Clear RBuffer
    j StringGet                              # Return to get first string again

# ============================================================================
# LOGIC FLOW:
# 1. First pop from stack gets the part count, saved in PartCount register
# 2. Subsequent pops get string chunks for display
# 3. When all strings are consumed, next pop will be the part count again
# 4. When part count is detected, reset stack pointer to loop the message
# 5. Process continues indefinitely, looping the same message
# ============================================================================ 




# Logic flow for new system:
#Get the message ID
# 